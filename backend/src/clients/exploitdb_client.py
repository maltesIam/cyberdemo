"""
ExploitDB Client.

ExploitDB provides exploit information including proof-of-concept code,
exploit metadata, and CVE associations.

Website: https://www.exploit-db.com/
Note: No public API available - this client generates synthetic/demo data.
In production, this could be integrated with a local searchsploit installation
or exploit-db mirror.
"""

import hashlib
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional

import httpx


logger = logging.getLogger(__name__)

# Constants
DEFAULT_TIMEOUT = 30  # seconds
EXPLOITDB_BASE_URL = "https://www.exploit-db.com/exploits/"

# Valid exploit types with their probabilities
EXPLOIT_TYPES = ["remote", "local", "webapps", "dos", "shellcode"]
EXPLOIT_TYPE_WEIGHTS = [60, 20, 15, 5, 0]  # Percentages (shellcode rarely 0)

# Valid platforms
VALID_PLATFORMS = {
    "windows", "linux", "unix", "multiple", "hardware",
    "android", "ios", "macos", "php", "java", "python",
    "webapps", "cgi", "asp", "aspx", "jsp"
}

# Sample authors for synthetic data
SAMPLE_AUTHORS = [
    "Anonymous", "metasploit", "Offensive Security",
    "EDB-ID Team", "SecuriTeam", "exploit-db",
    "Red Team Labs", "Core Security", "Rapid7"
]


class ExploitDBClient:
    """
    Client for ExploitDB exploit database.

    Provides exploit information including proof-of-concept code,
    exploit metadata, and CVE associations.

    In demo_mode, generates synthetic but realistic exploit data.
    """

    def __init__(self, demo_mode: bool = True, timeout: int = DEFAULT_TIMEOUT):
        """
        Initialize ExploitDB client.

        Args:
            demo_mode: If True, use synthetic data. If False, attempt real queries.
            timeout: Request timeout in seconds.
        """
        self.demo_mode = demo_mode
        self.timeout = timeout
        self.client = httpx.AsyncClient(timeout=timeout)

        # Cache for generated exploits (for consistency within a session)
        self._exploit_cache: Dict[str, Dict] = {}

    async def close(self):
        """Close the HTTP client."""
        await self.client.aclose()

    async def __aenter__(self):
        """Async context manager entry."""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.close()

    async def search_by_cve(
        self,
        cve_id: str,
        cvss_score: Optional[float] = None,
        is_kev: bool = False
    ) -> List[Dict]:
        """
        Search for exploits by CVE ID.

        Args:
            cve_id: The CVE identifier (e.g., "CVE-2021-44228").
            cvss_score: Optional CVSS score to influence number of results.
            is_kev: If True, indicates this is a Known Exploited Vulnerability.

        Returns:
            List of exploit dictionaries matching the CVE.
        """
        if self.demo_mode:
            return self._generate_synthetic_exploits(cve_id, cvss_score, is_kev)

        # Non-demo mode: attempt real request (but ExploitDB has no public API)
        return await self._search_real_api(cve_id)

    async def _search_real_api(self, cve_id: str) -> List[Dict]:
        """Attempt to search real ExploitDB (no public API available)."""
        try:
            # ExploitDB doesn't have a public API, so this would fail
            # In a real implementation, this could use searchsploit local database
            await self._make_request(f"/search?cve={cve_id}")
            return []
        except Exception as e:
            logger.warning(f"ExploitDB real API search failed (expected): {e}")
            return []

    async def _make_request(self, endpoint: str) -> Dict:
        """Make HTTP request (used for non-demo mode and testing)."""
        # This method exists primarily for mocking in tests
        url = f"https://www.exploit-db.com/api{endpoint}"
        response = await self.client.get(url)
        response.raise_for_status()
        return response.json()

    def _generate_synthetic_exploits(
        self,
        cve_id: str,
        cvss_score: Optional[float] = None,
        is_kev: bool = False
    ) -> List[Dict]:
        """
        Generate synthetic exploit data based on CVE characteristics.

        Higher CVSS scores generate more exploits.
        KEV status increases likelihood of verified exploits.
        """
        # Use hash of CVE ID for deterministic but varied results
        cve_hash = int(hashlib.md5(cve_id.encode()).hexdigest(), 16)

        # Check for "unknown" CVEs that shouldn't have exploits
        if "9999" in cve_id:
            return []

        # Determine number of exploits based on CVSS score
        if cvss_score is not None:
            if cvss_score >= 9.0:
                num_exploits = 3 + (cve_hash % 3)  # 3-5 exploits
            elif cvss_score >= 7.0:
                num_exploits = 2 + (cve_hash % 2)  # 2-3 exploits
            elif cvss_score >= 4.0:
                num_exploits = 1 + (cve_hash % 2)  # 1-2 exploits
            else:
                num_exploits = cve_hash % 2  # 0-1 exploits
        else:
            # Default: use hash to determine (1-3 exploits for "real" CVEs)
            num_exploits = 1 + (cve_hash % 3)

        exploits = []
        for i in range(num_exploits):
            exploit = self._generate_single_exploit(cve_id, cve_hash, i, is_kev)
            exploits.append(exploit)

            # Cache for later retrieval by ID
            self._exploit_cache[exploit["exploit_id"]] = exploit

        return exploits

    def _generate_single_exploit(
        self,
        cve_id: str,
        cve_hash: int,
        index: int,
        is_kev: bool = False
    ) -> Dict:
        """Generate a single synthetic exploit."""
        # Generate deterministic but varied exploit ID
        exploit_num = 50000 + ((cve_hash + index) % 10000)
        exploit_id = f"EDB-{exploit_num}"

        # Determine exploit type based on hash
        type_index = (cve_hash + index) % len(EXPLOIT_TYPES)
        exploit_type = EXPLOIT_TYPES[type_index]
        # Avoid shellcode (rare)
        if exploit_type == "shellcode":
            exploit_type = "remote"

        # Determine platform
        platforms = list(VALID_PLATFORMS)
        platform_index = (cve_hash + index * 7) % len(platforms)
        platform = platforms[platform_index]

        # Determine verified status
        # KEV vulnerabilities have higher chance of verified exploits
        if is_kev:
            verified = ((cve_hash + index) % 10) >= 3  # 70% verified for KEV
        else:
            verified = ((cve_hash + index) % 10) >= 6  # 40% verified normally

        # Generate date based on CVE year
        try:
            cve_year = int(cve_id.split("-")[1])
        except (IndexError, ValueError):
            cve_year = 2021

        # Exploit typically appears within 1-365 days after CVE
        days_after = (cve_hash % 365) + 1
        base_date = datetime(cve_year, 1, 1) + timedelta(days=days_after)
        # Ensure date is not in the future
        if base_date > datetime.now():
            base_date = datetime.now() - timedelta(days=(cve_hash % 30))
        date_published = base_date.strftime("%Y-%m-%d")

        # Generate author
        author_index = (cve_hash + index * 3) % len(SAMPLE_AUTHORS)
        author = SAMPLE_AUTHORS[author_index]

        # Generate title based on CVE and type
        titles = self._get_title_templates()
        title_index = (cve_hash + index * 5) % len(titles)
        title = titles[title_index].format(cve=cve_id, platform=platform.title())

        return {
            "exploit_id": exploit_id,
            "source": "exploitdb",
            "title": title,
            "type": exploit_type,
            "platform": platform,
            "verified": verified,
            "url": f"{EXPLOITDB_BASE_URL}{exploit_num}",
            "date_published": date_published,
            "author": author,
            "cve_id": cve_id
        }

    def _get_title_templates(self) -> List[str]:
        """Return list of exploit title templates."""
        return [
            "{platform} - Remote Code Execution ({cve})",
            "{platform} - Privilege Escalation Exploit",
            "{cve} - Buffer Overflow Exploit",
            "{platform} - Command Injection ({cve})",
            "{cve} - SQL Injection Vulnerability",
            "{platform} - Authentication Bypass",
            "{cve} - Arbitrary File Upload",
            "{platform} - Memory Corruption Exploit",
            "{cve} - Local Privilege Escalation",
            "{platform} - Remote Command Execution",
        ]

    async def get_exploit(self, exploit_id: str) -> Optional[Dict]:
        """
        Get exploit details by ExploitDB ID.

        Args:
            exploit_id: The ExploitDB ID (e.g., "EDB-51234").

        Returns:
            Dict with exploit details, or None if not found.
        """
        # Check cache first
        if exploit_id in self._exploit_cache:
            return self._exploit_cache[exploit_id]

        if self.demo_mode:
            # For demo mode, we only return cached exploits
            # (ones that were previously searched by CVE)
            return None

        # Non-demo mode would attempt real API
        return None

    async def search_by_platform(
        self,
        platform: str,
        type: Optional[str] = None
    ) -> List[Dict]:
        """
        Search for exploits by platform and optionally type.

        Args:
            platform: The target platform (e.g., "windows", "linux").
            type: Optional exploit type filter (e.g., "remote", "local").

        Returns:
            List of exploit dictionaries matching the criteria.
        """
        if self.demo_mode:
            return self._generate_platform_exploits(platform, type)

        # Non-demo mode would attempt real API
        return []

    def _generate_platform_exploits(
        self,
        platform: str,
        exploit_type: Optional[str] = None
    ) -> List[Dict]:
        """Generate synthetic exploits for a platform."""
        # Use platform name to generate deterministic results
        platform_hash = int(hashlib.md5(platform.encode()).hexdigest(), 16)

        # Generate 3-7 exploits for the platform
        num_exploits = 3 + (platform_hash % 5)

        exploits = []
        for i in range(num_exploits):
            # Generate pseudo-CVE for the exploit
            pseudo_cve = f"CVE-202{i % 5}-{(platform_hash + i) % 10000:04d}"

            exploit = self._generate_single_exploit(pseudo_cve, platform_hash, i)
            # Override platform to match request
            exploit["platform"] = platform

            # If type filter specified, set it
            if exploit_type:
                exploit["type"] = exploit_type

            # Update CVE ID
            exploit["cve_id"] = pseudo_cve

            exploits.append(exploit)
            self._exploit_cache[exploit["exploit_id"]] = exploit

        # Filter by type if specified
        if exploit_type:
            exploits = [e for e in exploits if e["type"] == exploit_type]

        return exploits
