"""
Vulnerability Enrichment MCP Tools.

Tools for enriching CVE vulnerabilities with threat intelligence,
SSVC classification, and risk assessment.

These tools enable AI agents to:
- Enrich CVEs with multi-source vulnerability data (NVD, EPSS, KEV, OSV)
- Get SSVC classification decisions
- Search enriched vulnerabilities
- Calculate composite risk scores
"""

from typing import Any, Dict, List

# Tool definitions for MCP registration
VULNERABILITY_TOOLS: List[Dict[str, Any]] = [
    {
        "name": "vuln_enrich_cve",
        "description": "Enrich one or more CVEs with vulnerability intelligence from multiple sources (NVD, EPSS, KEV, OSV). Returns CVSS scores, exploit probability, KEV status, and affected packages.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "cve_ids": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "List of CVE IDs to enrich (e.g., ['CVE-2024-1234', 'CVE-2024-5678']). Max 100 CVEs per request.",
                    "maxItems": 100
                },
                "sources": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "enum": ["nvd", "epss", "kev", "osv", "ghsa", "exploitdb"]
                    },
                    "description": "Sources to use for enrichment. Default: ['nvd', 'epss', 'kev']"
                },
                "force_refresh": {
                    "type": "boolean",
                    "description": "Bypass cache and fetch fresh data",
                    "default": False
                }
            },
            "required": ["cve_ids"]
        }
    },
    {
        "name": "vuln_get_ssvc_decision",
        "description": "Get SSVC (Stakeholder-Specific Vulnerability Categorization) decision for a CVE. Returns prioritization: Act, Attend, Track*, or Track based on exploitation status, automatability, and technical impact.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "cve_id": {
                    "type": "string",
                    "description": "CVE ID to classify (e.g., 'CVE-2024-1234')"
                },
                "is_kev": {
                    "type": "boolean",
                    "description": "Override KEV status. If not provided, will be fetched from KEV catalog."
                },
                "epss_score": {
                    "type": "number",
                    "description": "Override EPSS score (0.0-1.0). If not provided, will be fetched from EPSS."
                },
                "exploit_count": {
                    "type": "integer",
                    "description": "Number of known exploits. Default: 0"
                },
                "cvss_v3_score": {
                    "type": "number",
                    "description": "Override CVSS v3 score (0.0-10.0). If not provided, will be fetched from NVD."
                },
                "cvss_v3_vector": {
                    "type": "string",
                    "description": "CVSS v3 vector string (e.g., 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H')"
                }
            },
            "required": ["cve_id"]
        }
    },
    {
        "name": "vuln_search",
        "description": "Search enriched vulnerabilities with filters. Returns matching CVEs with their enrichment data.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "ssvc_decision": {
                    "type": "string",
                    "enum": ["Act", "Attend", "Track*", "Track"],
                    "description": "Filter by SSVC decision"
                },
                "risk_level": {
                    "type": "string",
                    "enum": ["Critical", "High", "Medium", "Low"],
                    "description": "Filter by risk level"
                },
                "min_cvss_score": {
                    "type": "number",
                    "description": "Minimum CVSS v3 score (0.0-10.0)"
                },
                "min_epss_score": {
                    "type": "number",
                    "description": "Minimum EPSS score (0.0-1.0)"
                },
                "is_kev": {
                    "type": "boolean",
                    "description": "Filter by KEV status (in CISA Known Exploited Vulnerabilities)"
                },
                "cwe_id": {
                    "type": "string",
                    "description": "Filter by CWE ID (e.g., 'CWE-79')"
                },
                "affected_product": {
                    "type": "string",
                    "description": "Filter by affected product name"
                },
                "limit": {
                    "type": "integer",
                    "description": "Maximum number of results to return",
                    "default": 50,
                    "maximum": 100
                },
                "offset": {
                    "type": "integer",
                    "description": "Offset for pagination",
                    "default": 0
                }
            }
        }
    },
    {
        "name": "vuln_get_risk_assessment",
        "description": "Get composite risk score for a CVE. Combines CVSS, EPSS, KEV status, exploit maturity, and exposure data into a 0-100 risk score with component breakdown.",
        "inputSchema": {
            "type": "object",
            "properties": {
                "cve_id": {
                    "type": "string",
                    "description": "CVE ID to assess (e.g., 'CVE-2024-1234')"
                },
                "cvss_v3_score": {
                    "type": "number",
                    "description": "CVSS v3 score (0.0-10.0). If not provided, will be fetched."
                },
                "epss_score": {
                    "type": "number",
                    "description": "EPSS score (0.0-1.0). If not provided, will be fetched."
                },
                "is_kev": {
                    "type": "boolean",
                    "description": "KEV status. If not provided, will be checked."
                },
                "exploit_maturity": {
                    "type": "string",
                    "enum": ["weaponized", "poc", "unproven", "none"],
                    "description": "Exploit availability level. Default: 'none'"
                },
                "affected_critical_assets": {
                    "type": "integer",
                    "description": "Number of critical assets affected. Default: 0"
                },
                "total_critical_assets": {
                    "type": "integer",
                    "description": "Total critical assets in scope. Default: 1"
                },
                "shodan_exposed_count": {
                    "type": "integer",
                    "description": "Number of internet-exposed instances. Default: 0"
                }
            },
            "required": ["cve_id"]
        }
    }
]


async def handle_vuln_enrich_cve(args: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handle vuln_enrich_cve tool call.

    Enriches CVEs using the VulnerabilityEnrichmentService.
    """
    from ...services.vuln_enrichment_service import VulnerabilityEnrichmentService

    cve_ids = args.get("cve_ids", [])
    sources = args.get("sources")
    force_refresh = args.get("force_refresh", False)

    # Validate CVE IDs
    if not isinstance(cve_ids, list):
        raise ValueError("cve_ids must be a list")

    if len(cve_ids) == 0:
        raise ValueError("cve_ids cannot be empty")

    if len(cve_ids) > 100:
        raise ValueError("Maximum 100 CVEs per request")

    for cve_id in cve_ids:
        if not isinstance(cve_id, str):
            raise ValueError("Each CVE ID must be a string")
        if not cve_id.upper().startswith("CVE-"):
            raise ValueError(f"Invalid CVE ID format: {cve_id}")

    # Call the enrichment service
    service = VulnerabilityEnrichmentService()
    result = await service.enrich_vulnerabilities(
        cve_ids=cve_ids,
        sources=sources,
        force_refresh=force_refresh
    )

    return result


async def handle_vuln_get_ssvc_decision(args: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handle vuln_get_ssvc_decision tool call.

    Calculates SSVC decision for a CVE.
    """
    from ...services.ssvc_calculator import SSVCCalculator
    from ...services.vuln_enrichment_service import VulnerabilityEnrichmentService

    cve_id = args.get("cve_id")
    if not cve_id:
        raise ValueError("cve_id is required")

    # Get enrichment data if not all values provided
    is_kev = args.get("is_kev")
    epss_score = args.get("epss_score")
    cvss_v3_score = args.get("cvss_v3_score")
    cvss_v3_vector = args.get("cvss_v3_vector")
    exploit_count = args.get("exploit_count", 0)

    # If any data is missing, fetch from enrichment service
    if is_kev is None or epss_score is None or cvss_v3_score is None:
        service = VulnerabilityEnrichmentService()
        enriched = await service.enrich_single_cve(cve_id)

        if is_kev is None:
            is_kev = enriched.get("is_kev", False)
        if epss_score is None:
            epss_score = enriched.get("epss_score", 0.0)
        if cvss_v3_score is None:
            cvss_v3_score = enriched.get("cvss_v3_score", 0.0)
        if cvss_v3_vector is None:
            cvss_v3_vector = enriched.get("cvss_v3_vector")

    # Calculate SSVC decision
    calculator = SSVCCalculator()
    result = calculator.calculate_ssvc_decision(
        is_kev=is_kev,
        epss_score=epss_score or 0.0,
        exploit_count=exploit_count,
        cvss_v3_score=cvss_v3_score or 0.0,
        cvss_v3_vector=cvss_v3_vector
    )

    return {
        "cve_id": cve_id,
        "ssvc_decision": result["decision"],
        "exploitation_status": result["exploitation"],
        "automatable": result["automatable"],
        "technical_impact": result["technical_impact"],
        "mission_prevalence": result["mission_prevalence"],
        "input_data": {
            "is_kev": is_kev,
            "epss_score": epss_score,
            "cvss_v3_score": cvss_v3_score,
            "cvss_v3_vector": cvss_v3_vector,
            "exploit_count": exploit_count
        }
    }


async def handle_vuln_search(args: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handle vuln_search tool call.

    Searches vulnerabilities with optional filters.
    Returns synthetic demo data for demonstration.
    """
    import random
    import hashlib
    from datetime import datetime, timedelta

    ssvc_decision = args.get("ssvc_decision")
    risk_level = args.get("risk_level")
    min_cvss_score = args.get("min_cvss_score")
    min_epss_score = args.get("min_epss_score")
    is_kev = args.get("is_kev")
    cwe_id = args.get("cwe_id")
    affected_product = args.get("affected_product")
    limit = min(args.get("limit", 50), 100)
    offset = args.get("offset", 0)

    # Generate synthetic vulnerabilities for demo
    vulnerabilities = _generate_synthetic_vulnerabilities(limit + offset + 50)

    # Apply filters
    filtered = vulnerabilities
    if ssvc_decision:
        filtered = [v for v in filtered if v["ssvc_decision"] == ssvc_decision]
    if risk_level:
        filtered = [v for v in filtered if v["risk_level"] == risk_level]
    if min_cvss_score is not None:
        filtered = [v for v in filtered if v["cvss_v3_score"] >= min_cvss_score]
    if min_epss_score is not None:
        filtered = [v for v in filtered if v["epss_score"] >= min_epss_score]
    if is_kev is not None:
        filtered = [v for v in filtered if v["is_kev"] == is_kev]
    if cwe_id:
        filtered = [v for v in filtered if cwe_id in v.get("cwe_ids", [])]
    if affected_product:
        product_lower = affected_product.lower()
        filtered = [v for v in filtered if any(
            product_lower in p.lower() for p in v.get("affected_products", [])
        )]

    # Apply pagination
    paginated = filtered[offset:offset + limit]

    return {
        "vulnerabilities": paginated,
        "total_count": len(filtered),
        "limit": limit,
        "offset": offset,
        "filters_applied": {
            "ssvc_decision": ssvc_decision,
            "risk_level": risk_level,
            "min_cvss_score": min_cvss_score,
            "min_epss_score": min_epss_score,
            "is_kev": is_kev,
            "cwe_id": cwe_id,
            "affected_product": affected_product
        }
    }


async def handle_vuln_get_risk_assessment(args: Dict[str, Any]) -> Dict[str, Any]:
    """
    Handle vuln_get_risk_assessment tool call.

    Calculates composite risk score for a CVE.
    """
    from ...services.vuln_risk_score import VulnRiskScoreCalculator
    from ...services.vuln_enrichment_service import VulnerabilityEnrichmentService

    cve_id = args.get("cve_id")
    if not cve_id:
        raise ValueError("cve_id is required")

    # Get input values or fetch from enrichment
    cvss_v3_score = args.get("cvss_v3_score")
    epss_score = args.get("epss_score")
    is_kev = args.get("is_kev")
    exploit_maturity = args.get("exploit_maturity", "none")
    affected_critical_assets = args.get("affected_critical_assets", 0)
    total_critical_assets = args.get("total_critical_assets", 1)
    shodan_exposed_count = args.get("shodan_exposed_count", 0)

    # If any required data is missing, fetch from enrichment service
    if cvss_v3_score is None or epss_score is None or is_kev is None:
        service = VulnerabilityEnrichmentService()
        enriched = await service.enrich_single_cve(cve_id)

        if cvss_v3_score is None:
            cvss_v3_score = enriched.get("cvss_v3_score", 0.0)
        if epss_score is None:
            epss_score = enriched.get("epss_score", 0.0)
        if is_kev is None:
            is_kev = enriched.get("is_kev", False)

    # Calculate risk score
    calculator = VulnRiskScoreCalculator()
    result = calculator.calculate_risk_score(
        cvss_v3_score=cvss_v3_score or 0.0,
        epss_score=epss_score or 0.0,
        is_kev=is_kev or False,
        exploit_maturity=exploit_maturity,
        affected_critical_assets=affected_critical_assets,
        total_critical_assets=total_critical_assets,
        shodan_exposed_count=shodan_exposed_count
    )

    return {
        "cve_id": cve_id,
        "risk_score": result["risk_score"],
        "risk_level": result["risk_level"],
        "components": result["components"],
        "input_data": {
            "cvss_v3_score": cvss_v3_score,
            "epss_score": epss_score,
            "is_kev": is_kev,
            "exploit_maturity": exploit_maturity,
            "affected_critical_assets": affected_critical_assets,
            "total_critical_assets": total_critical_assets,
            "shodan_exposed_count": shodan_exposed_count
        }
    }


def _generate_synthetic_vulnerabilities(count: int) -> List[Dict[str, Any]]:
    """Generate synthetic vulnerability data for demo purposes."""
    import random
    from datetime import datetime, timedelta

    products = [
        "Apache Log4j", "OpenSSL", "Spring Framework", "PostgreSQL",
        "Redis", "Nginx", "Node.js", "Django", "WordPress", "Kubernetes"
    ]

    cwe_ids_list = [
        "CWE-79", "CWE-89", "CWE-94", "CWE-200", "CWE-287",
        "CWE-502", "CWE-611", "CWE-918", "CWE-74", "CWE-352"
    ]

    ssvc_decisions = ["Act", "Attend", "Track*", "Track"]
    risk_levels = ["Critical", "High", "Medium", "Low"]

    vulnerabilities = []
    for i in range(count):
        random.seed(i + 1000)  # Deterministic for consistent results

        year = random.choice([2023, 2024, 2025])
        cve_num = 10000 + i
        cve_id = f"CVE-{year}-{cve_num}"

        cvss_score = round(random.uniform(0.0, 10.0), 1)
        epss_score = round(random.uniform(0.0, 1.0), 4)
        is_kev = random.random() > 0.85  # 15% in KEV

        # Determine SSVC based on scores
        if is_kev or epss_score > 0.7:
            ssvc = "Act" if cvss_score >= 9.0 else "Attend"
        elif cvss_score >= 7.0 or epss_score > 0.3:
            ssvc = "Track*" if epss_score > 0.1 else "Track"
        else:
            ssvc = "Track"

        # Risk level based on composite
        risk_score = (cvss_score / 10 * 40) + (epss_score * 30) + (15 if is_kev else 0)
        if risk_score >= 85:
            risk_level = "Critical"
        elif risk_score >= 70:
            risk_level = "High"
        elif risk_score >= 40:
            risk_level = "Medium"
        else:
            risk_level = "Low"

        vuln = {
            "cve_id": cve_id,
            "cvss_v3_score": cvss_score,
            "epss_score": epss_score,
            "is_kev": is_kev,
            "ssvc_decision": ssvc,
            "risk_level": risk_level,
            "risk_score": round(risk_score, 1),
            "cwe_ids": random.sample(cwe_ids_list, k=random.randint(1, 2)),
            "affected_products": random.sample(products, k=random.randint(1, 3)),
            "description": f"Vulnerability in {random.choice(products)} allowing remote code execution.",
            "published_date": (datetime.now() - timedelta(days=random.randint(1, 365))).isoformat(),
            "last_modified": datetime.now().isoformat()
        }
        vulnerabilities.append(vuln)

    return vulnerabilities


# Handler mapping for MCP registration
vulnerability_handlers = {
    "vuln_enrich_cve": handle_vuln_enrich_cve,
    "vuln_get_ssvc_decision": handle_vuln_get_ssvc_decision,
    "vuln_search": handle_vuln_search,
    "vuln_get_risk_assessment": handle_vuln_get_risk_assessment,
}
