"""
Unit tests for ExploitDB Client.

ExploitDB provides exploit information including proof-of-concept code,
exploit metadata, and CVE associations.

Website: https://www.exploit-db.com/
Note: No public API - this client generates synthetic/demo data.

These tests are written FIRST following TDD (RED phase).
"""

import pytest
from unittest.mock import AsyncMock, patch, MagicMock
import httpx

# Import will fail until we implement the module (RED phase)
try:
    from src.clients.exploitdb_client import ExploitDBClient
except ImportError:
    pass


# ==============================================================================
# Test 1: Client Creation
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_client_creation():
    """
    RED: Test that ExploitDBClient can be instantiated with default settings.

    Expected behavior:
    - Client is created with demo_mode=True by default
    - Default timeout is 30 seconds
    """
    client = ExploitDBClient()

    assert client.demo_mode is True
    assert client.timeout == 30

    await client.close()


@pytest.mark.asyncio
async def test_exploitdb_client_custom_timeout():
    """
    RED: Test that ExploitDBClient can be created with custom timeout.

    Expected behavior:
    - Custom timeout value is applied
    """
    client = ExploitDBClient(timeout=60)

    assert client.timeout == 60

    await client.close()


# ==============================================================================
# Test 2: Search by CVE - Found
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_search_by_cve_found():
    """
    RED: Test that search_by_cve returns exploits for a known CVE.

    Expected behavior:
    - Return a list of exploit dictionaries
    - Each exploit has required fields: exploit_id, source, title, type, platform, verified, url, date_published
    """
    client = ExploitDBClient(demo_mode=True)

    # CVE-2021-44228 is Log4Shell - a well-known critical vulnerability
    results = await client.search_by_cve("CVE-2021-44228")

    # Should return at least one exploit
    assert isinstance(results, list)
    assert len(results) >= 1

    # Verify structure of first result
    exploit = results[0]
    assert "exploit_id" in exploit
    assert exploit["exploit_id"].startswith("EDB-")
    assert exploit["source"] == "exploitdb"
    assert "title" in exploit
    assert exploit["type"] in ["remote", "local", "webapps", "dos", "shellcode"]
    assert "platform" in exploit
    assert "verified" in exploit
    assert isinstance(exploit["verified"], bool)
    assert "url" in exploit
    assert exploit["url"].startswith("https://www.exploit-db.com/exploits/")
    assert "date_published" in exploit

    await client.close()


# ==============================================================================
# Test 3: Search by CVE - Not Found
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_search_by_cve_not_found():
    """
    RED: Test that search_by_cve returns empty list for unknown CVE.

    Expected behavior:
    - Return empty list for CVE that has no known exploits
    """
    client = ExploitDBClient(demo_mode=True)

    # A made-up CVE that shouldn't have exploits
    results = await client.search_by_cve("CVE-9999-99999")

    # Should return empty list, not None or error
    assert isinstance(results, list)
    assert len(results) == 0

    await client.close()


# ==============================================================================
# Test 4: Get Exploit by ID - Found
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_get_exploit_found():
    """
    RED: Test that get_exploit returns exploit details for known ID.

    Expected behavior:
    - Return dict with exploit details
    - All required fields present
    """
    client = ExploitDBClient(demo_mode=True)

    # First search for a CVE to get an exploit ID
    search_results = await client.search_by_cve("CVE-2021-44228")
    assert len(search_results) >= 1

    exploit_id = search_results[0]["exploit_id"]

    # Now get that exploit by ID
    result = await client.get_exploit(exploit_id)

    assert result is not None
    assert result["exploit_id"] == exploit_id
    assert result["source"] == "exploitdb"
    assert "title" in result
    assert "type" in result
    assert "platform" in result
    assert "verified" in result
    assert "url" in result

    await client.close()


# ==============================================================================
# Test 5: Get Exploit by ID - Not Found
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_get_exploit_not_found():
    """
    RED: Test that get_exploit returns None for unknown ID.

    Expected behavior:
    - Return None for non-existent exploit ID
    """
    client = ExploitDBClient(demo_mode=True)

    # Non-existent exploit ID
    result = await client.get_exploit("EDB-99999999")

    assert result is None

    await client.close()


# ==============================================================================
# Test 6: Search by Platform
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_search_by_platform():
    """
    RED: Test that search_by_platform returns exploits for given platform.

    Expected behavior:
    - Return list of exploits for the specified platform
    - All returned exploits have the correct platform
    """
    client = ExploitDBClient(demo_mode=True)

    results = await client.search_by_platform("windows")

    assert isinstance(results, list)
    assert len(results) >= 1

    # All results should be for windows platform
    for exploit in results:
        assert exploit["platform"] == "windows"

    await client.close()


# ==============================================================================
# Test 7: Search by Platform and Type
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_search_by_platform_and_type():
    """
    RED: Test that search_by_platform can filter by type as well.

    Expected behavior:
    - Return list of exploits matching both platform AND type
    """
    client = ExploitDBClient(demo_mode=True)

    results = await client.search_by_platform("linux", type="local")

    assert isinstance(results, list)

    # If results exist, they should match both platform and type
    for exploit in results:
        assert exploit["platform"] == "linux"
        assert exploit["type"] == "local"

    await client.close()


# ==============================================================================
# Test 8: Synthetic Data Varies by CVE
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_synthetic_data_varies_by_cve():
    """
    RED: Test that synthetic data varies based on CVE input.

    Expected behavior:
    - Different CVEs produce different results (deterministic but varied)
    - Same CVE always produces same results (reproducible)
    """
    client = ExploitDBClient(demo_mode=True)

    # Get results for two different CVEs
    results1 = await client.search_by_cve("CVE-2021-44228")
    results2 = await client.search_by_cve("CVE-2020-1234")

    # Run again to verify consistency
    results1_again = await client.search_by_cve("CVE-2021-44228")

    # Results should be reproducible
    assert len(results1) == len(results1_again)
    if len(results1) > 0:
        assert results1[0]["exploit_id"] == results1_again[0]["exploit_id"]

    await client.close()


# ==============================================================================
# Test 9: High CVSS = More Exploits
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_high_cvss_more_exploits():
    """
    RED: Test that search can consider CVSS score for number of exploits.

    Expected behavior:
    - Higher CVSS score typically produces more exploits
    - Method can accept optional cvss_score parameter
    """
    client = ExploitDBClient(demo_mode=True)

    # Search with high CVSS score
    high_cvss_results = await client.search_by_cve("CVE-2021-44228", cvss_score=9.8)

    # Search with low CVSS score
    low_cvss_results = await client.search_by_cve("CVE-2021-99999", cvss_score=2.0)

    # High CVSS should typically produce more exploits
    # (This is a synthetic rule, so we can verify the logic)
    assert len(high_cvss_results) >= len(low_cvss_results)

    await client.close()


# ==============================================================================
# Test 10: Verified Exploits for KEV
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_verified_exploits_for_kev():
    """
    RED: Test that KEV (Known Exploited Vulnerabilities) get verified exploits.

    Expected behavior:
    - When is_kev=True, exploits are more likely to be verified
    """
    client = ExploitDBClient(demo_mode=True)

    # Search with KEV flag
    kev_results = await client.search_by_cve("CVE-2021-44228", is_kev=True)

    # At least some should be verified for KEV
    if len(kev_results) > 0:
        verified_count = sum(1 for e in kev_results if e["verified"])
        # For KEV, at least 50% should be verified
        assert verified_count >= len(kev_results) * 0.5

    await client.close()


# ==============================================================================
# Test 11: Handles Timeout
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_handles_timeout():
    """
    RED: Test timeout handling (for non-demo mode).

    Expected behavior:
    - When demo_mode=False and request times out, return empty list
    """
    client = ExploitDBClient(demo_mode=False, timeout=5)

    with patch.object(client, '_make_request', new_callable=AsyncMock) as mock_request:
        mock_request.side_effect = httpx.TimeoutException("Request timed out")

        result = await client.search_by_cve("CVE-2021-44228")

        # Should return empty list on timeout
        assert result == []

    await client.close()


# ==============================================================================
# Test 12: Client Close
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_client_close():
    """
    RED: Test that client can be properly closed.

    Expected behavior:
    - close() method completes without error
    """
    client = ExploitDBClient()

    # Should not raise any exceptions
    await client.close()


# ==============================================================================
# Test 13: Context Manager Support
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_context_manager():
    """
    RED: Test that client supports async context manager.

    Expected behavior:
    - Can use 'async with' statement
    - Client is properly closed on exit
    """
    async with ExploitDBClient(demo_mode=True) as client:
        results = await client.search_by_cve("CVE-2021-44228")
        assert isinstance(results, list)

    # Client should be closed after context exits
    # (We can't easily verify this without accessing internal state)


# ==============================================================================
# Test 14: Exploit Types Valid
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_exploit_types_valid():
    """
    RED: Test that all exploit types are valid.

    Expected behavior:
    - All returned exploits have type in valid set
    """
    client = ExploitDBClient(demo_mode=True)

    valid_types = {"remote", "local", "webapps", "dos", "shellcode"}

    # Search for various CVEs
    test_cves = ["CVE-2021-44228", "CVE-2020-0001", "CVE-2019-1234"]

    for cve in test_cves:
        results = await client.search_by_cve(cve)
        for exploit in results:
            assert exploit["type"] in valid_types, f"Invalid type: {exploit['type']}"

    await client.close()


# ==============================================================================
# Test 15: Platforms Valid
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_platforms_valid():
    """
    RED: Test that all platforms are valid.

    Expected behavior:
    - All returned exploits have platform in valid set
    """
    client = ExploitDBClient(demo_mode=True)

    valid_platforms = {
        "windows", "linux", "unix", "multiple", "hardware",
        "android", "ios", "macos", "php", "java", "python",
        "webapps", "cgi", "asp", "aspx", "jsp"
    }

    # Search for exploits
    results = await client.search_by_cve("CVE-2021-44228")

    for exploit in results:
        assert exploit["platform"] in valid_platforms, f"Invalid platform: {exploit['platform']}"

    await client.close()


# ==============================================================================
# Test 16: CVE ID in Exploit Response
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_cve_id_in_response():
    """
    RED: Test that CVE ID is included in exploit response.

    Expected behavior:
    - Exploits returned for a CVE include the cve_id field
    """
    client = ExploitDBClient(demo_mode=True)

    cve_id = "CVE-2021-44228"
    results = await client.search_by_cve(cve_id)

    for exploit in results:
        assert "cve_id" in exploit
        assert exploit["cve_id"] == cve_id

    await client.close()


# ==============================================================================
# Test 17: Author Field Present
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_author_field_present():
    """
    RED: Test that author field is present in exploit data.

    Expected behavior:
    - Each exploit has an 'author' field
    """
    client = ExploitDBClient(demo_mode=True)

    results = await client.search_by_cve("CVE-2021-44228")

    for exploit in results:
        assert "author" in exploit
        assert isinstance(exploit["author"], str)
        assert len(exploit["author"]) > 0

    await client.close()


# ==============================================================================
# Test 18: Date Published Format
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_date_published_format():
    """
    RED: Test that date_published is in correct format (YYYY-MM-DD).

    Expected behavior:
    - date_published matches ISO date format
    """
    import re

    client = ExploitDBClient(demo_mode=True)

    results = await client.search_by_cve("CVE-2021-44228")

    date_pattern = re.compile(r"^\d{4}-\d{2}-\d{2}$")

    for exploit in results:
        assert "date_published" in exploit
        assert date_pattern.match(exploit["date_published"]), \
            f"Invalid date format: {exploit['date_published']}"

    await client.close()


# ==============================================================================
# Test 19: URL Format Valid
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_url_format_valid():
    """
    RED: Test that exploit URL is correctly formatted.

    Expected behavior:
    - URL points to exploit-db.com with correct exploit ID
    """
    client = ExploitDBClient(demo_mode=True)

    results = await client.search_by_cve("CVE-2021-44228")

    for exploit in results:
        assert "url" in exploit
        assert exploit["url"].startswith("https://www.exploit-db.com/exploits/")

        # Extract ID from URL and verify it matches exploit_id
        url_id = exploit["url"].split("/")[-1]
        expected_id = exploit["exploit_id"].replace("EDB-", "")
        assert url_id == expected_id

    await client.close()


# ==============================================================================
# Test 20: Demo Mode vs Non-Demo Mode
# ==============================================================================
@pytest.mark.asyncio
async def test_exploitdb_demo_mode_flag():
    """
    RED: Test that demo_mode flag is respected.

    Expected behavior:
    - demo_mode=True uses synthetic data
    - demo_mode=False would use real API (but returns empty for safety)
    """
    # Demo mode client
    demo_client = ExploitDBClient(demo_mode=True)
    assert demo_client.demo_mode is True

    # Non-demo mode client
    non_demo_client = ExploitDBClient(demo_mode=False)
    assert non_demo_client.demo_mode is False

    await demo_client.close()
    await non_demo_client.close()
